<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AETHERIUM // NotebookLM NEXT</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Inter:wght@300;400;600&display=swap');
        :root {
            --accent-primary: #00f3ff; --accent-secondary: #bc13fe;
            --glass-bg: rgba(20, 20, 30, 0.8); --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.05);
        }
        body {
            background-color: #050508;
            background-image:
                radial-gradient(circle at 10% 20%, rgba(188, 19, 254, 0.2) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(0, 243, 255, 0.15) 0%, transparent 40%);
            color: #e0e0e0; font-family: 'Inter', sans-serif;
            overflow: hidden; height: 100vh; margin: 0;
        }
        .glass-panel {
            background: var(--glass-bg); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border); box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }
        .glass-input {
            background: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.1);
            color: white; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .glass-input:focus, .glass-input:focus-within {
            background: rgba(0, 0, 0, 0.6); border-color: var(--accent-primary);
            outline: none; box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
        }
        .nav-item {
            position: relative; transition: all 0.3s ease;
            color: rgba(255,255,255,0.5); cursor: pointer;
        }
        .nav-item::before {
            content: ''; position: absolute; left: 0; top: 50%;
            transform: translateY(-50%); width: 3px; height: 0%;
            background: var(--accent-primary); transition: height 0.3s ease;
            border-radius: 0 2px 2px 0; box-shadow: 0 0 10px var(--accent-primary);
        }
        .nav-item:hover { color: white; background: var(--glass-highlight); }
        .nav-item.active { color: white; background: linear-gradient(90deg, rgba(0,243,255,0.1), transparent); }
        .nav-item.active::before { height: 70%; }
        .nav-item.active i { color: var(--accent-primary); filter: drop-shadow(0 0 5px rgba(0,243,255,0.5)); }
        .font-tech { font-family: 'Rajdhani', sans-serif; }
        .synergy-orb {
             animation: pulse-glow 3s infinite ease-in-out;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 15px rgba(188, 19, 254, 0.4); }
            50% { box-shadow: 0 0 35px rgba(188, 19, 254, 0.8); }
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }
    </style>
</head>
<body>
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const FEATURES = {
            AUDIO: 'Audio Overview', VIDEO: 'Video Overview', MIND_MAP: 'Mind Map', REPORT: 'Report',
            DATA_TABLE: 'Data Table', LEARNING: 'Flashcards & Quizzes', INFOGRAPHIC: 'Infographic', SLIDE_DECK: 'Slide Deck'
        };

        const Generator = () => {
            const [apiKey, setApiKey] = useState("");
            const [activeTab, setActiveTab] = useState(FEATURES.AUDIO);

            const [featureGoals, setFeatureGoals] = useState({
                [FEATURES.AUDIO]: "Create an interactive podcast dialogue between two experts, summarizing the document. Allow for user interjections.",
                [FEATURES.VIDEO]: "Generate a script for a whiteboard-style explainer video, detailing the core project concepts.",
                [FEATURES.MIND_MAP]: "Analyze the document\'s structure and generate a Mermaid.js graph to visualize key entities and their relationships.",
                [FEATURES.REPORT]: "Write a professional report with a full citation list, including an executive summary, methodology, and conclusion.",
                [FEATURES.DATA_TABLE]: "Extract all relevant data points from the source and structure them into a clean, exportable table (e.g., for Google Sheets).",
                [FEATURES.LEARNING]: "Create a comprehensive set of difficult flashcards and a multiple-choice quiz based on the key information.",
                [FEATURES.INFOGRAPHIC]: "Design a vertical infographic summarizing the main statistics and findings for a presentation.",
                [FEATURES.SLIDE_DECK]: "Generate a full slide deck outline, including content for each slide and prompt-based revision capabilities."
            });
            
            const [sourceContent, setSourceContent] = useState("");
            const [blueprint, setBlueprint] = useState("");
            const [sourceStrategy, setSourceStrategy] = useState("Auto");
            const [generatedOutput, setGeneratedOutput] = useState("");

            const [isGenerating, setIsGenerating] = useState(false);
            const [isSynergizing, setIsSynergizing] = useState(false);
            const [isRefining, setIsRefining] = useState(false);
            const [aiError, setAiError] = useState("");

            // --- Config States ---
            const [audioConfig, setAudioConfig] = useState({ format: 'Deep Dive', host1: 'Expert Analyst', host2: 'Curious Student' });
            const [videoConfig, setVideoConfig] = useState({ style: 'Whiteboard', focus: 'Core Concepts' });
            const [mindMapConfig, setMindMapConfig] = useState({ format: 'Mermaid.js' });
            const [dataTableConfig, setDataTableConfig] = useState({ export: 'Google Sheets' });
            const [learningConfig, setLearningConfig] = useState({ difficulty: 'Hard', quiz_items: 10 });
            const [infographicConfig, setInfographicConfig] = useState({ orientation: 'Vertical' });
            const [slideDeckConfig, setSlideDeckConfig] = useState({ revisions: 'Prompt-Based' });

            const fileInputRef = useRef(null);

            const callGemini = async (promptText, forSynergy = false) => {
                setAiError("");
                if (!apiKey) { setAiError("AETHERIUM requires a Gemini API Key to function."); return null; }
                try {
                    const model = forSynergy ? "gemini-1.5-pro-latest" : "gemini-1.5-flash-latest";
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }], generationConfig: { responseMimeType: "application/json" } })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error.message || 'AI Service Unavailable');
                    }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
                } catch (error) {
                    console.error("Gemini API call failed:", error);
                    setAiError(`API Connection Error: ${error.message}`);
                    return null;
                }
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => setSourceContent(event.target.result);
                reader.readAsText(file);
            };

            const handleAutoSynergy = async () => {
                if (!sourceContent.trim() && !blueprint.trim()) {
                    setAiError("Auto Synergy requires either source content or a blueprint.");
                    return;
                }
                setIsSynergizing(true);
                const synergyPrompt = `
You are the Auto Synergy core of AETHERIUM, acting as a "Pedagogical Architect." Your mission is to engineer a comprehensive, multi-feature learning plan from a user's source material and strategic goals.

**PRIMARY DIRECTIVE:** The user's "Structural Blueprint" is the GROUND TRUTH. If it specifies a structure (e.g., "7 learning units"), all generated goals MUST adhere to this structure.

**INPUTS:**
1.  **Source Preview (Raw Text):** """${sourceContent.slice(0, 15000)}..."""
2.  **Structural Blueprint (User Intent):** """${blueprint}"""
3.  **Source Strategy:** "${sourceStrategy}" - Adapt your analysis accordingly:
    *   **Micro-Analysis:** (1-2 sources) Treat every sentence as a critical data point. Focus on granular detail.
    *   **Deep Synthesis:** (3-10 sources) Focus on connecting ideas and citations across documents.
    *   **Macro-Exhaustion:** (10+ sources) Identify high-level patterns, themes, and outliers across the entire corpus.

**METHODOLOGY: Chain of Thought (CoT)**
For each of the 8 features below, perform a silent CoT analysis to determine the most effective "User Goal."
*   Analyze the source and blueprint.
*   Which parts of the source are best suited for this feature? (e.g., timelines -> Audio, comparisons -> Data Table).
*   Formulate a specific, actionable goal.

**OUTPUT:**
Return ONLY a single, valid JSON object containing optimized goals and configurations for ALL of the following features. Do not add any explanatory text outside the JSON.

**JSON STRUCTURE:**
{
  "Audio Overview": { "goal": "...", "config": { "format": "...", "host1": "...", "host2": "..." } },
  "Video Overview": { "goal": "...", "config": { "style": "...", "focus": "..." } },
  "Mind Map": { "goal": "...", "config": { "format": "..." } },
  "Report": { "goal": "...", "config": {} },
  "Data Table": { "goal": "...", "config": { "export": "..." } },
  "Flashcards & Quizzes": { "goal": "...", "config": { "difficulty": "...", "quiz_items": ... } },
  "Infographic": { "goal": "...", "config": { "orientation": "..." } },
  "Slide Deck": { "goal": "...", "config": { "revisions": "..." } }
}
`;

                const result = await callGemini(synergyPrompt, true);
                if (result) {
                    try {
                        const data = JSON.parse(result);
                        const newGoals = {};
                        for (const key in data) {
                            const featureName = Object.values(FEATURES).find(f => f.toLowerCase().includes(key.toLowerCase().replace(/_/g, ' ')));
                            if (featureName && data[key].goal) {
                                newGoals[featureName] = data[key].goal;
                            }
                            if (featureName && data[key].config) {
                                if (featureName === FEATURES.AUDIO) setAudioConfig(c => ({...c, ...data[key].config}));
                                if (featureName === FEATURES.VIDEO) setVideoConfig(c => ({...c, ...data[key].config}));
                                if (featureName === FEATURES.MIND_MAP) setMindMapConfig(c => ({...c, ...data[key].config}));
                                if (featureName === FEATURES.DATA_TABLE) setDataTableConfig(c => ({...c, ...data[key].config}));
                                if (featureName === FEATURES.LEARNING) setLearningConfig(c => ({...c, ...data[key].config}));
                                if (featureName === FEATURES.INFOGRAPHIC) setInfographicConfig(c => ({...c, ...data[key].config}));
                                if (featureName === FEATURES.SLIDE_DECK) setSlideDeckConfig(c => ({...c, ...data[key].config}));
                            }
                        }
                        setFeatureGoals(g => ({...g, ...newGoals}));
                    } catch (e) { setAiError("Auto Synergy failed to parse AI response."); console.error(e); }
                }
                setIsSynergizing(false);
            };
            
            const handleRefineGoal = async () => {
                const currentGoal = featureGoals[activeTab];
                if (!currentGoal) { setAiError("Cannot refine an empty goal."); return; }
                setIsRefining(true);
                const refinePrompt = `You are a Chain of Thought (CoT) prompt optimizer. Your task is to refine the following user goal for the \"${activeTab}\" feature into a more powerful, detailed, and authoritative steering prompt for an AI. Use a step-by-step reasoning process, then output the final, refined prompt in a single, dense paragraph. USER GOAL: \"${currentGoal}\"`;
                const result = await callGemini(refinePrompt, false);
                 if (result) {
                    try {
                         // Assuming the actual prompt is the last part of the CoT
                        const parsedResult = JSON.parse(result);
                        const refinedPrompt = parsedResult.refined_prompt || result;
                        setFeatureGoals(prev => ({...prev, [activeTab]: refinedPrompt.trim()}));
                    } catch (e) { 
                        // If it fails to parse, it might be plain text.
                        setFeatureGoals(prev => ({...prev, [activeTab]: result.trim()}));
                    } 
                }
                setIsRefining(false);
            };

            const generateAetherOutput = async () => {
                if (!sourceContent.trim() || !featureGoals[activeTab]) {
                    setAiError("Source content and a goal are required to generate an output.");
                    return;
                }
                setIsGenerating(true);
                setGeneratedOutput("");

                const steeringPrompt = `As a master Prompt Engineer, your task is to generate the final "Steering Prompt" for NotebookLM. This prompt will be executed by another AI. Your output must be ONLY the prompt itself.

**DIRECTIVES:**
1.  **Authoritative Language:** Use direct, commanding language.
2.  **Strict Isolation:** The prompt must be self-contained for the specified feature module. Prohibit the AI from using knowledge or context from other features.
3.  **Source Grounding:** Mandate that all answers derive exclusively from the provided source document.

**INPUTS FOR YOUR PROMPT:**
*   **Feature Module:** "${activeTab}"
*   **User Goal:** "${featureGoals[activeTab]}"
*   **Source Strategy:** "${sourceStrategy}" (Incorporate this logic into your prompt, e.g., instructing the AI to perform "micro-analysis" or "macro-exhaustion").

**TASK:**
Synthesize the above inputs into a single, powerful, and executable Steering Prompt. Begin the prompt directly, without preamble.`;

                const result = await callGemini(steeringPrompt, false);
                if (result) {
                    try {
                        const parsedResult = JSON.parse(result);
                        setGeneratedOutput(parsedResult.prompt || result);
                    } catch (e) {
                        setGeneratedOutput(result);
                    }
                }
                setIsGenerating(false);
            };
            
            const getIcon = (feature) => {
                switch(feature) {
                    case FEATURES.AUDIO: return "fa-headphones";
                    case FEATURES.VIDEO: return "fa-video";
                    case FEATURES.MIND_MAP: return "fa-project-diagram";
                    case FEATURES.REPORT: return "fa-file-invoice";
                    case FEATURES.DATA_TABLE: return "fa-table-list";
                    case FEATURES.LEARNING: return "fa-graduation-cap";
                    case FEATURES.INFOGRAPHIC: return "fa-chart-pie";
                    case FEATURES.SLIDE_DECK: return "fa-person-chalkboard";
                    default: return "fa-star";
                }
            };

            const renderConfig = () => {
                // Config rendering logic here, adapted for new features...
                return <div className="text-gray-400 p-4 text-sm">Configuration for {activeTab}</div>;
            };

            return (
                <div className="flex h-screen w-full overflow-hidden font-sans">
                    {/* SIDEBAR */}
                    <div className="w-72 glass-panel flex flex-col p-4 space-y-2 border-r border-white/5 overflow-y-auto">
                        <div className="mb-4 text-center">
                             <h1 className="text-3xl font-tech font-bold text-accent-primary leading-none">AETHERIUM</h1>
                             <span className="text-xs font-mono text-accent-secondary tracking-widest">NOTEBOOKLM NEXT</span>
                        </div>
                        <div className="mb-4">
                            <label className="block text-[10px] uppercase tracking-widest text-gray-400 mb-2">Gemini API Key</label>
                            <input type="password" className="glass-input w-full p-2 rounded text-xs font-mono" placeholder="Required for AI functions..." value={apiKey} onChange={(e) => setApiKey(e.target.value)} />
                        </div>
                        <div className="space-y-1">
                            {Object.values(FEATURES).map(feature => (
                                <div key={feature} className={`nav-item p-3 rounded-lg flex items-center space-x-4 text-sm font-medium ${activeTab === feature ? 'active' : ''}`} onClick={() => setActiveTab(feature)}>
                                    <i className={`fas ${getIcon(feature)} w-5 text-center`}></i>
                                    <span>{feature}</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* MAIN CONTENT */}
                    <div className="flex-1 grid grid-cols-3 gap-6 p-6 overflow-hidden bg-black/20">
                        
                        {/* Col 1: Source & Blueprint */}
                        <div className="glass-panel rounded-2xl p-5 flex flex-col space-y-4">
                            <h3 className="font-tech text-lg text-accent-primary">1. Source & Strategy</h3>
                            <div className="flex-1 flex flex-col space-y-3">
                               <button onClick={() => fileInputRef.current.click()} className="w-full glass-input p-2 rounded-lg hover:bg-white/5 transition text-sm">
                                    <i className="fas fa-file-upload mr-2"></i> Upload Document
                                </button>
                                <input type="file" ref={fileInputRef} onChange={handleFileUpload} className="hidden" />
                                <textarea className="glass-input w-full flex-1 p-3 rounded-xl text-xs font-mono resize-none" placeholder="Or paste source text here..." value={sourceContent} onChange={(e) => setSourceContent(e.target.value)} />
                            </div>
                            <div>
                                <label className="text-xs text-gray-400 mb-1">Source Strategy</label>
                                <select className="glass-input w-full p-2 rounded text-sm" value={sourceStrategy} onChange={e => setSourceStrategy(e.target.value)}>
                                    <option className="text-black">Auto</option>
                                    <option className="text-black">Micro-Analysis</option>
                                    <option className="text-black">Deep Synthesis</option>
                                    <option className="text-black">Macro-Exhaustion</option>
                                </select>
                            </div>
                        </div>

                        {/* Col 2: Goal & Synergy */}
                        <div className="glass-panel rounded-2xl p-5 flex flex-col space-y-4">
                             <h3 className="font-tech text-lg text-accent-secondary">2. Goal & Synergy</h3>
                             <div className="flex-1 flex flex-col space-y-3">
                                <label className="text-sm">Goal for <span className="font-bold text-white">{activeTab}</span></label>
                                <textarea className="glass-input w-full flex-1 p-3 rounded-xl text-sm resize-none" placeholder="Describe your desired output..." value={featureGoals[activeTab]} onChange={(e) => setFeatureGoals({...featureGoals, [activeTab]: e.target.value})} />
                                <button onClick={handleRefineGoal} disabled={isRefining} className="w-full glass-input p-2 rounded-lg hover:bg-white/5 transition text-sm disabled:opacity-50">
                                    {isRefining ? 'Refining...' : 'Refine Goal with CoT'}
                                </button>
                            </div>
                            <div className="border-t border-white/10 pt-4">
                                <h4 className="font-tech text-md mb-2">Auto-Synergy Blueprint</h4>
                                <textarea className="glass-input w-full h-24 p-3 rounded-xl text-xs resize-none" placeholder="Describe your overall project objective..." value={blueprint} onChange={(e) => setBlueprint(e.target.value)} />
                                <button onClick={handleAutoSynergy} disabled={isSynergizing} className="mt-2 w-full bg-gradient-to-r from-purple-600 to-cyan-600 p-3 rounded-xl font-bold text-sm tracking-wider synergy-orb disabled:opacity-50">
                                    {isSynergizing ? <i className="fas fa-sync fa-spin"></i> : "Run Auto-Synergy"}
                                </button>
                            </div>
                        </div>

                        {/* Col 3: Output */}
                        <div className="glass-panel rounded-2xl p-5 flex flex-col relative shadow-2xl">
                             <div className="flex justify-between items-center mb-4">
                                <h3 className="font-tech text-lg">3. Aether Output</h3>
                                <button onClick={generateAetherOutput} disabled={isGenerating} className="bg-white text-black px-5 py-2 rounded-xl font-bold text-sm shadow-lg hover:scale-105 transition disabled:opacity-50">
                                    {isGenerating ? "GENERATING..." : "GENERATE"}
                                </button>
                            </div>
                            <div className="flex-1 relative bg-black/40 rounded-lg p-1">
                                <textarea className="w-full h-full bg-transparent outline-none font-mono text-sm text-cyan-300 resize-none p-3" readOnly value={isGenerating ? "// Generating Steering Prompt..." : (generatedOutput || "// Aether Output will be generated here.")} />
                                {generatedOutput && <button onClick={() => navigator.clipboard.writeText(generatedOutput)} className="absolute bottom-2 right-2 glass-input px-3 py-1 rounded-lg text-xs hover:bg-white/10"><i className="fas fa-copy mr-2"></i>Copy</button>}
                            </div>
                             {aiError && <div className="mt-3 p-3 bg-red-900/50 border border-red-500/30 rounded-lg text-red-300 text-xs font-mono"><i className="fas fa-triangle-exclamation mr-2"></i> {aiError}</div>}
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<Generator />);
    </script>
</body>
</html>